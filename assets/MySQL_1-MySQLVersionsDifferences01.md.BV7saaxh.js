import{_ as a,c as s,o as e,a5 as i}from"./chunks/framework.BlKpNptw.js";const c=JSON.parse('{"title":"MySQL 数据库版本差异(一)问题解析","description":"数据库死锁是致命的问题","frontmatter":{"description":"数据库死锁是致命的问题","title":"MySQL 数据库版本差异(一)问题解析","readingTime":false,"tag":["MySQL"],"recommend":3},"headers":[],"relativePath":"MySQL/1-MySQLVersionsDifferences01.md","filePath":"MySQL/1-MySQLVersionsDifferences01.md","lastUpdated":1755138831000}'),r={name:"MySQL/1-MySQLVersionsDifferences01.md"};function n(o,t,d,l,h,g){return e(),s("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1755138831000"},t[0]||(t[0]=[i('<h1 id="mysql-数据库5-5版本问题-死锁" tabindex="-1">MySQL 数据库5.5版本问题 <strong>死锁</strong> <a class="header-anchor" href="#mysql-数据库5-5版本问题-死锁" aria-label="Permalink to &quot;MySQL 数据库5.5版本问题 **死锁**&quot;">​</a></h1><p>数据库版本<strong>MySQL 5.5</strong></p><h3 id="_1-死锁概念" tabindex="-1">1. 死锁概念 <a class="header-anchor" href="#_1-死锁概念" aria-label="Permalink to &quot;1. 死锁概念&quot;">​</a></h3><p>• 死锁是指两个或多个事务在互相等待对方持有的资源，从而导致所有事务都无法继续执行的一种情况。</p><h3 id="_2-问题代码如下" tabindex="-1">2. 问题代码如下: <a class="header-anchor" href="#_2-问题代码如下" aria-label="Permalink to &quot;2. 问题代码如下:&quot;">​</a></h3><p>• ALTER TABLE • 对表进行操作 • 同时有查询</p><div class="language-SQL vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">SQL</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> student </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> COLUMN </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`age`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> DEFAULT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> COMMENT </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;年龄&#39;</span></span></code></pre></div><p>出现问题 <strong><code>Waiting for table metadata lock</code></strong> 的等待场景，导致了后台服务查询缓慢，卡住。</p><h3 id="_3-原因分析" tabindex="-1">3. 原因分析 <a class="header-anchor" href="#_3-原因分析" aria-label="Permalink to &quot;3. 原因分析&quot;">​</a></h3><p>因为 ALTER TABLE的时候导致锁表，查询的时候，就进行了排队，发生了阻塞，当程序强制退出的时候，就又是的刚才ALTER TABLE的事务没有提交，导出一直发生阻塞，造成了大量的进程发生了阻塞 。</p><h3 id="_4-解决方式" tabindex="-1">4. 解决方式： <a class="header-anchor" href="#_4-解决方式" aria-label="Permalink to &quot;4. 解决方式：&quot;">​</a></h3><p>1.show processlist;</p><p>发现ALTER TABLE这条语句导致大量查询语句处于等待状态<code>Waiting for table metadata lock</code></p><p>2.kill {id}; 将处于处于等待的进程杀掉！</p><h3 id="_5-mysql-5-5-与-5-6-特性对比" tabindex="-1">5. MySQL 5.5 与 5.6 特性对比 <a class="header-anchor" href="#_5-mysql-5-5-与-5-6-特性对比" aria-label="Permalink to &quot;5. MySQL 5.5 与 5.6 特性对比&quot;">​</a></h3><p>以下是 <strong>MySQL 5.5</strong> 和 <strong>MySQL 5.6</strong> 版本的主要功能差异对比，涵盖性能、存储引擎、优化器、复制、安全等方面：</p><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><strong>MySQL 5.5</strong></th><th><strong>MySQL 5.6</strong></th></tr></thead><tbody><tr><td><strong>全文索引</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>InnoDB online DDL</strong></td><td>不支持</td><td>部分支持</td></tr><tr><td><strong>REDO</strong></td><td>最大支持4 GB</td><td>最大支持512 GB</td></tr><tr><td><strong>刷脏</strong></td><td>单线程</td><td>单独的刷脏线程</td></tr><tr><td><strong>purge</strong></td><td>单线程</td><td>多线程</td></tr><tr><td><strong>EXCHANGE PARTITION</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>DML显式指定分区</strong></td><td>不支持</td><td>支持</td></tr></tbody></table><h3 id="_6-总结-mysql-5-6-的主要优势" tabindex="-1">6. 总结：MySQL 5.6 的主要优势 <a class="header-anchor" href="#_6-总结-mysql-5-6-的主要优势" aria-label="Permalink to &quot;6. 总结：MySQL 5.6 的主要优势&quot;">​</a></h3><ol><li><strong>性能提升</strong>：通过多线程 I/O、MRR、BKA 等优化，显著提升查询和写入性能。</li><li><strong>高可用性</strong>：支持并行复制、GTID、动态半同步复制，简化故障恢复。</li><li><strong>易用性</strong>：Online DDL、Memcached 接口、分区表增强，减少维护停机时间。</li><li><strong>安全性</strong>：密码策略、SSL 默认启用，提升数据保护能力。</li></ol><hr><h3 id="_7-适用场景建议" tabindex="-1">7. 适用场景建议 <a class="header-anchor" href="#_7-适用场景建议" aria-label="Permalink to &quot;7. 适用场景建议&quot;">​</a></h3><ul><li><strong>MySQL 5.5</strong>：适合对性能要求不高、需稳定运行的传统应用，或作为旧系统迁移的过渡版本。</li><li><strong>MySQL 5.6</strong>：推荐用于需要高并发、高可用性、复杂查询优化的场景（如电商平台、金融系统）。</li></ul>',22)]))}const k=a(r,[["render",n]]);export{c as __pageData,k as default};
